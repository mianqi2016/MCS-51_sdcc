//Source code under CC0 1.0
//A program showing 8-digit random number generated by STC89C516RD+

#include "main.h"

//2 4-digits diaplay drived by 1 74HC245 and 1 74HC138
//74HC245 - Octal Bus Transceivers With 3-State Outputs
//74HC245 connected to Port 0 (Pin 0.0 - 0.7) - driving 8 segments
//74HC138 - High-Speed CMOS Logic 3- to 8-Line Decoder/Demultiplexer Inverting and Noninverting
//74HC138 connectted to Port 2 (Pin 2.2-2.3-2.4) - altering in 8 digits

//Configure timer for 11.0592 Mhz default SYSCLK
//Timer0 used for key-press debounce
//Timer1 used for segments showing delay - POV(Persistence of Vision)
//Timer2 used for random number generating

//2 Keys pull-up for HMI
//Key_0 (INT0/Pin 3.2) used for display clearing
//Key_1 (INT1/Pin 3.3) used for random number generating and showing)

//Enable Timer0, Timer1, Timer2, EXTI0 and EXTI1 interrupts
//Enable general interrupt
//Bit Addressable: EA  EC  ET2  ES  ET1  EX1  ET0  EX0
//	      Bit:  7   6    5   4    3    2    1    0
//IE = 0xAF;	//1010 1111B 


void main(void)
{
	IE = 0xAF;	//1010 1111B
	
	//Timer0 run in mode 2 - 8-bit auto-reload mode
	//Timer1 would be turn on/off by 1-0 on Pin3.3(INT1)
	//so using Timer0 for Key4 (INT1)
	//Timer1 run in mode 1 - 16-bit
	TMOD = 0x12;
	TH0 = 0x00;	//Timer0 run in mode 2 with auto-reload value = 0

	//Timer2 run in mode "AUTO-RELOAD"
	T2MOD = 0x00;
	//Start Timer2 - reload value default
	T2CON_TR2 = 1;

	//Set EXTI0 low level triggered
	//Set EXTI1 falling edge triggered
	TCON_IT0 = 0;
	TCON_IT1 = 1;

	while(1)
	{
		if(flag_display_showing == true)
		{
			//number_display_generator();

			numberDisplay(number_display_showing[i_subscript_array], i_subscript_array);
			displayPOV();
		//		for(int i = 0; i < 32767; ++i);
		//		if(i_subscript_array > 7) i_subscript_array = 0;

		} else
		{
			//DISPLAY_CLEAR;
			P0 = 0x00;
		}
	}
}

//**********************display.c**********************
void segmentDisplay(unsigned int segment)
{
	P0 = display_segment[segment];
}

void digitDisplay(unsigned int digit)
{
	P2 = display_digit[digit];
}

void numberDisplay(unsigned int segment, unsigned int digit)
{
	segmentDisplay(segment);
	digitDisplay(digit);
}


//********************timer.c*****************************
//There are total 5 interrupts used in this program
//THere are total 3 timer overflow used
//THere are total 2 EXTI used
//11.0592 MHz defualt SYSCLK

//Timer0 used for key debounce - 50 ms
//Timer0 worked in mode 0
//TL0=0x1F.
//11059200 / 256 / 32 = 1350
//1350 / 50 = 27
//CONST value for counting of Timer0 overflows is "VALUE_KEY_DEBOUNCE"
void ticksTimer0Update(void) __interrupt(1)
{
	ticksTimer0++;
	clockTimer0Update = true;
}

unsigned int getTicksTimer0(void)
{
	unsigned int clockTemp;

	do
	{
		clockTimer0Update = false;
		clockTemp = ticksTimer0;
	} while(clockTimer0Update);

	return (clockTemp);
}


//Timer1 used for digits showing POV - almost equal to 25 ms
//Timer1 run in mode 1
//11059200 / 65536 = 168(.75)
//168 / 42 = 4
//CONST value for counting of Timer1 overflows is "VALUE_DISPLAY_POV"

void ticksTimer1Update(void) __interrupt(3)
{
	ticksTimer1++;
	clockTimer1Update = true;
}

unsigned int getTicksTimer1(void)
{
	unsigned int clockTemp;

	do
	{
		clockTimer1Update = false;
		clockTemp = ticksTimer1;
	} while(clockTimer1Update);
	

	return (clockTemp);
}

void displayPOV(void)
{
	if(flag_display_POV == false)
	{
		flag_display_POV = true;
		ticksTimer0 = 0;
		TCON_TR0 = 1;	// start Timer0
	} else
	{
		value_display_pov = getTicksTimer0();
		if(value_display_pov >= VALUE_DISPLAY_POV)
		{
			flag_display_POV = false;
			value_display_pov = 0;
			TCON_TR0 = 0;	// STOP Timer0
			i_subscript_array++;
			if(i_subscript_array > 7) i_subscript_array = 0;
		} else
		{
			;
		}
        }
	

}


//******************************timer.c******************************
//Timer0 run in mode 0
//Timer1 run in mode 1
//TMOD = 0x10;
//TL0 = 0x1F;	//Timer0 run in mode 0 with prescaler = 32



// Timer 2 used for random number generating

void ticksTimer2Update(void) __interrupt(5)
{
	ticksTimer2++;
	clockTimer2Update = true;
	T2CON_TF2 = 0;	// TF2 should be cleared by software 
	random_number_generator();
}

unsigned long getTicksTimer2(void)
{
	unsigned long clockTemp;

	do
	{
		clockTimer2Update = false;
		clockTemp = ticksTimer2;
	} while(clockTimer2Update);

	return (clockTemp);
}


// Timer2 used for random number generating
void random_number_generator(void)
{
	// random_number_raw counting Timer2 overfolws for 8-digit display
	unsigned long random_number_raw = 0;
	random_number_raw = getTicksTimer2();
	number_display_pending[i_subscript_array] = random_number_raw % 10;
	i_subscript_array++;
	if(i_subscript_array >  7) i_subscript_array = 0;
}


//Timer2 run in mode "AUTO-RELOAD"
//T2MOD = 0x00;

// 2 EXTI used in this program
// Key3 connected to EXTI0 (P3_2), used for clearing display - stop showing
// Key4 connected to EXTI1 (P3_3), used for altering number shown on displayi


// In order to use any of the interrupts in the MCS-51, the following 3 steps must be taken:
// 1. Set the EA (enable all) bit in the IE register to 1.
// 2. Set the corresponding individual interrupt enable bit in the IE register to 1.
// Begin the interrupt service routine at the corresponding Vector Address of that interrupt. 
// See Table below:
// Interrupt Source	Vector Address
// 		IE0		0003H
// 		TF0		000BH
// 		IE1		0013H
// 		TF1		001BH
// 		RI & TI		0023H
// 		TF2 & EXF2	002BH
// In addition, for external interrupts, pins !INT0 and !INT1 (P3.2 and P3.3) must be set to 1, 
// and depending on whether the interrupt is to be level or transition activated, 
// bits IT0 or IT1 in the TCON register may need to be set to 1.

//Set EXTI0 low level triggered
//Set EXTI1 falling edge triggered
//TCON_IT0 = 0;
//TCON_IT1 = 1;

//*******************************exti.c**************************************
// EXT0 ISR:

void key3Pressed(void)  __interrupt(0)
{
	KEY_3 = false;
	P0 = 0x00;	//shut-down all digits displaying
	//DISPLAY_CLEAR;
	flag_display_showing = false;
}

// EXTI1 ISR:
void key4Pressed(void)  __interrupt(2)
{
//	flag_key4_debounce = true;
//	for(int i = 0; i < 8; ++i)
//	{i
//
		number_display_generator();
//		random_number_generator();
//	}
//	number_display_generator();
	flag_display_showing = true;
}

//KEY_4 debounce
void key4Debounce(void)
{
	if(flag_key4_debounce == false)
	{
		flag_key4_debounce = true;
		value_key4_debounce = 0;	// set defualt value
		TCON_TR0 = 1;	// start Timer0

	} else 
	{
		value_key4_debounce = getTicksTimer0();
		if(value_key_debounce >= VALUE_KEY_DEBOUNCE_RANGE)
		{
			KEY_4 = false;
			flag_key4_debounce = false;
		} else if(value_key_debounce >= VALUE_KEY_DEBOUNCE)
			{
				KEY_4 = true;
				value_key_debounce = 0;
				TCON_TR0 = 0x00;	//stop running Timer0
				flag_display_showing = true;
				number_display_generator();
			} else
			{
				;
			}
	}
}

void number_display_generator(void)
{
	int i = 0;

	for(i = 0; i < 8; ++i)
	{
		number_display_showing[i] = number_display_pending[i];
	}

}

