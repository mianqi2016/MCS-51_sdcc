#ifndef __MAIN_H__
#define __MAIN_H__

#include <stdbool.h>

// STC89xx series is  produced by STC MCU Limited, is a 8-bit mcu with 
// compatible instruction sets with 80C51 series mcu.


// IE - Interrupt Enable Register
// Address = 0A8H
// Reset Value = 0000 0000B
// Bit Addressable:	EA	EC	ET2	ES	ET1	EX1	ET0	EX0
// Bit			7	6	5	4	3	2	1	0
// Bit = 0: enables the interrupt
// Bit = 1: disables the interrupt
__sfr __at(0xA8) IE;

//*****************************display.h***************************
// used by 74HC245 - Octal bus Transceivers with 3-state outputs 
// const unsigned int display_segment[10] = {};
// 1-digit display pinouts:
//   _a_
//  |   |
//  f   b
//  |   |
//  |-g-|
//  |   |
//  e   c
//  |_ _|dp
//    d
// number pinout(abcdefg) binary(Port 0.0-0.7)  hexi
//                        0b.gfedcba
//   0    abcdef          0b00111111		0x3f
//   1    bc	          0b00000110		0x06
//   2    abdeg           0b01011011            0x5b
//   3    abcdg           0b01001111		0x4f
//   4    bcfg		  0b01100110            0x66
//   5    acdfg           0b01101101		0x6d
//   6    acdefg          0b01111101		0x7d
//   7    abc             0b00000111            0x07
//   8    abcdefg         0b01111111		0x7f
//   9    abcdfg          0b01101111		0x6f


// segment 0 - 9
const unsigned int display_segment[10] = {
	0x3f,
	0x06,
	0x5b,
	0x4f,
	0x66,
	0x6d,
	0x7d,
	0x07,
	0x7f,
	0x6f
};


// array for digit 1 - 8
// used by 74HC138 - High speed CMOS logic 3-to-8 line decoder/demultiplexer  
// const unsigned int display_digit[8] = {};
// digit pinout(74HC138 A2 - A4)  binary(Port 2.2 - 2.4) 	hex
//   1		00000			0b00000000		0x00
//   2		00100			0b00000100		0x04
//   3		01000			0b00001000		0x08
//   4		01100			0b00001100		0x0c
//   5		10000			0b00010000		0x10
//   6		10100			0b00010100		0x14
//   7		11000			0b00011000		0x18
//   8		11100			0b00011100		0x1c


// digit 0 - 8
const unsigned int display_digit[8] = {
	0x00, 
	0x04, 
	0x08, 
	0x0c, 
	0x10, 
	0x14, 
	0x18, 
	0x1c
};


// Prototype of function showing 1-digit (0 - 9):
void segmentDisplay(unsigned int segment);

// Prototype of function showing in 8 digits (digit0 - digit7)
void digitDisplay(unsigned int digit);

// Prototype of function showing 8-digit number:
void numberDisplay(unsigned int segment, unsigned int digit);


// Pin 0 - 7 on Port 0 connected to 74HC245
__sfr __at(0x80) P0;

// Pin 2 - 4 on Port 2 connected to 74HC138
__sfr __at(0xA0) P2;

// Pin 2 - 4 on Port 2 connected to 74HC138
__sbit __at(0xA0+2) P2_2;
__sbit __at(0xA0+3) P2_3;
__sbit __at(0xA0+4) P2_4;

#define DISPLAY_CLEAR P0 = 0xFF;	// shut-down all digits displaying

//*******************timer.h******************************************

// There are total 5 interrupts used in this program
// There are total 3 timer overflow used
// There are total 2 EXTI used

// 11.0592 MHz defualt SYSCLK
// Timer 0 used for key debounce - 50 ms
// Timer 1 used for digits showing POV - 25 ms
// Timer 2 used for random number generating - everytime timer overflow 

#include <stdbool.h>

//******************************************************************************
//
// The Timer 0 and Timer 1 Interrupts are generated by TF0 and TF1, which are set
// by a rollover in their respective Timer/Counter registers (except see Timer 0 in Mode 3).
// When a timer interrupt is generated , the flag that generated it is cleared 
// by the on-chip hardware when the service routine is vectored to.

__sfr __at(0x88) TCON;	// Reset value: 0000 0000B
// Bit addressable: TF1	TR1  TF0  TR0  IE1  IT1  IE0  IT0
//	       Bit:   7	  6    5    4    3    2    1    0

__sbit __at(0x88+4) TCON_TR0;
__sbit __at(0x88+6) TCON_TR1;

__sfr __at(0x89) TMOD;	// Reset value: 0000 0000B
			//      <--TIMER1   TIMER0-->
// Bit addressable: GATE   C/!T   M1   M0   GATE   C/!T   M1   M0
//             Bit:    7	     6    5    4      3      2    1    0
__sfr __at(0x8C) TH0;
__sfr __at(0x8A) TL0;

//******************************************************************************
//
//Timer0 worked in mode 0
// Mode 0 is an 8-bit Counter with a divide-by-32 prescaler.
// In this mode, the Timer register is configured as a 13-bit register.
// The 13-Bit register consists of all 8 bits of THx and the lower 5 bits of TLx.
// Setting the run flag (TRx) does not clear the registers.
// 11059200 / 236 / 32 = 1350
// 1350 / 50 = 27

volatile unsigned int ticksTimer0 = 0;
volatile _Bool clockTimer0Update = true;

void ticksTimer0Update(void) __interrupt(1);
unsigned int getTicksTimer0(void);

//KEY_4 debounce
unsigned int value_key_debounce = 0;
void key4Debounce(void);

//*******************************************************************************
//
//Timer1 work in mode 1
// Mode 1 is the same as Mode 0, except that the Timer register uses all 16 bits.
// In this mode, THx and TLx are cascaded, there is no prescaler.
// 11.0592 MHz default SYSCLK
// Each overflow increases 65536 ticks, 11059200 / 65536 = 168(168.75)
// 168 / 42 = 4 

//Timer0 run in mode 3 - auto-reload with value in TH0
//11059200 / 256 = 43200
//43200 / 100 = 432	//1s / 100 = 10ms(100Hz)
// 1 second / 4 almost equals to 40 Hz (25 ms) in 11.0592 MHz
#define VALUE_DISPLAY_POV 4

unsigned int value_display_pov = 0;
void displayPOV(void);

_Bool flag_display_POV = false;

volatile unsigned int ticksTimer1 = 0;
volatile _Bool clockTimer1Update = true;

void ticksTimer1Update(void) __interrupt(3);
unsigned int getTicksTimer1(void);

//********************************************************************************
//
//In the 8052, the Timer 2 Interrupt is generated by the logic OR of TF2 and EXF2.
// Neither of these flags is cleared by hardware when the service routine is vectored to.
// In fact, the service routine may have to determine whether it was TF2 or EXF2 that
// generated the interrupt, and the bit will have to be cleared in software.

// Timer2 worked in AUTO-RELOAD mode
// Upon reset the DCEN bit is set to 0 so that Timer 2 will default to count up.
// Timer 2 automatically counting up when DCEN = 0.
// In this mode, if EXAN2 in T2CON = 0, Timer2 counts up to 0FFFFh and then sets the TF2 bit upon overfloaw.
// The overflow also causes the timer registers to be reloaded with the 16-bit value in RCAP2H and RCAP2L.
// The values in RCAP2H and RCAP2L are preset by software.

__sfr __at(0xC9) T2MOD;	// Reset value: 0000 0000B
// Bit Addressable:  -   -   -   -   -   -   T2OE   DCEN   
//             Bit:  7   6   5   4   3   2      1      0

__sfr __at(0xC8) T2CON;	// Reset value: 0000 0000B (8052 only) 
// Bit Addressable:  TF2  EXF2  RCLK  TCLK  EXEN2  TR2  C/!T2  CP/!RL2 
//             Bit:    7     6     5     4      3    2      1        0
//             TF2:  Timer2 overflow flag, set by hardware and cleared by software
//            EXF2:  Timer2 external flag set when either a capture or reload is caused by a negative transition
//                   on T2EX and EXEN2=1. EXF2 must cleared by software.
//            RCLK:  Receive clock flag.
//            TCLK:  Transmit clock flag.
//           EXEN2:  Timer2 external enable flag, when set, allows a capture or reload to accur as a result of
//                   negative transition on T2EX if Timer2 is not used to clock the Serial Port.
//             TR2:  Software START/STOP control for Timer2, a logic 1 starts the timer.
//           C/!T2:  Timer / Counter select.
//         CP/!RL2:  Capture / Reload flag. 
__sbit __at(0xC8+2) T2CON_TR2;
__sbit __at(0xC8+7) T2CON_TF2;

__sfr __at(0xCA) RCAP2L;
__sfr __at(0xCB) RCAP2H;

volatile unsigned long ticksTimer2 = 0;
volatile _Bool clockTimer2Update = true;

void ticksTimer2Update(void) __interrupt(5);
unsigned long getTicksTimer2(void);

// Timer 2 used for random number genarating:
// Random number generator fot 8-digit display:
void random_number_generator(void);

//**********************exti.h********************************

//There are total 5 interrupts used in this program
//There are total 3 timer overflow used
//There are total 2 EXTI used
//Key3 connected to EXTI0, used for clearing display - stop showing
//Key4 connected to EXTI1, used for altering number shown on display

//The 8051 prodies 5 interrupt sources, the 8052 provides 6.

//#include <8052.h>

//The External Interrupts !INT0 and !INT1 can each be either level-activated or
//transition-activated, depending on bits IT0 and IT1 in Register TCON.
//The flags that actually generate these interrupts are bits IE0 and IE1 in TCON.
//TCON: timer/counter control register
//Bit Addressable: TF1  TR1  TF0  TR0  IE1  IT1  IE0  IT0
//            Bit:   7    6    5    4    3    2    1    0
//IE1 - TCON.3 - External Interrupt 1 edge flag. Set by hardware when External Interrupt
//edge is detected, cleared by hardware when interrupt is processed.
//IT1 - TCON.2 Interrupt 1 type control bit. Set/cleared by software to specify falling edge/low level
//triggered External Interrupt.
//IE0 - TCON.1 - External Interrupt 0 edge flag. Set by hardware when External Interrupt edge detected.
//Cleared by hardware when interrupt is processed.
//IT0 - TCON.0 - Interrupt 0 type control bit. Set/cleared by software to specify falling edge/low level
//triggered External Interrupt.
//Reset value: 0000 0000B
//If ITx=0, Low level; If ITx=1, edge-triggered.

__sfr __at(0x88) TCON;
__sbit __at(0x88+0) TCON_IT0;
__sbit __at(0x88+2) TCON_IT1;
__sbit __at(0x88+4) TCON_TR0;
__sbit __at(0x88+6) TCON_TR1;

//When an external interrupt is generated, the flag that generated it is cleared by the harware
//when the service routine is vectored to only if the interruptwas transition-activated.
//If the interrupt was level-activated, then the external requesting source is what
//controls the request flag, rather than the on-chip hardware.

//All of the bits that generates interrupts can be set or cleared by software, //with the same result as though it had been set or cleared by hardware. THat is,
//interrupts can be generated or pending interrupts can be canceled in software.


//11.0592 MHz defualt SYSCLK


volatile _Bool KEY_3 = true;
volatile _Bool KEY_4 = true;

_Bool flag_display_showing = true;
_Bool flag_key4_debounce = false;

//Timer0 worked in mode 0
//Mode 0 is an 8-bit Counter with a divide-by-32 prescaler.
//In this mode, the Timer register is configured as a 13-bit register.
//The 13-Bit register consists of all 8 bits of THx and the lower 5 bits of TLx.
//Setting the run flag (TRx) does not clear the registers.
//11059200 / 236 / 32 = 1350
//1350 / 50 = 27
#define VALUE_KEY_DEBOUNCE 27
#define VALUE_KEY_DEBOUNCE_RANGE 270	// almost equals to 0.5 second

//KEY_4 debounce
unsigned int value_key4_debounce = 0;
void key4Debounce(void);

void key3Pressed(void) __interrupt(0);
void key4Pressed(void) __interrupt(2);

//Transfer random_number_pending into number_display_showing
void number_display_generator(void);

// subscript of random number literal array:
unsigned int i_subscript_array = 0;

// Random number waiting to be shown on 8-digit display literally:
volatile unsigned int number_display_pending[8] = {0, 0, 0, 0, 0, 0, 0, 0};

// Random number was showing on display
unsigned int number_display_showing[8] = {1, 2, 3, 4, 5, 6, 7, 8};

#endif
